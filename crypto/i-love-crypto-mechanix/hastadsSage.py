
# This file was *autogenerated* from the file hastads.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_500 = Integer(500); _sage_const_2048 = Integer(2048); _sage_const_16 = Integer(16)
def hastads(cArray,nArray,e=_sage_const_3 ):
    """
    Performs Hastads attack on raw RSA with no padding.
    cArray = Ciphertext Array
    nArray = Modulus Array
    e = public exponent
    """

    if(len(cArray)==len(nArray)==e):
        for i in range(e):
            cArray[i] = Integer(cArray[i])
            nArray[i] = Integer(nArray[i])
        M = crt(cArray,nArray)
        return(Integer(M).nth_root(e,truncate_mode=_sage_const_1 ))
    else:
        print("CiphertextArray, ModulusArray, need to be of the same length, and the same size as the public exponent")


def linearPaddingHastads(cArray,nArray,aArray,bArray,e=_sage_const_3 ,eps=_sage_const_1 /_sage_const_8 ):
    """
    Performs Hastads attack on raw RSA with no padding.
    This is for RSA encryptions of the form: cArray[i] = pow(aArray[i]*msg + bArray[i],e,nArray[i])
    Where they are all encryptions of the same message.
    cArray = Ciphertext Array
    nArray = Modulus Array
    aArray = Array of 'slopes' for the linear padding
    bArray = Array of 'y-intercepts' for the linear padding
    e = public exponent
    """
    if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == e):
        for i in range(e):
            cArray[i] = Integer(cArray[i])
            nArray[i] = Integer(nArray[i])
            aArray[i] = Integer(aArray[i])
            bArray[i] = Integer(bArray[i])
        TArray = [-_sage_const_1 ]*e
        for i in range(e):
            arrayToCRT = [_sage_const_0 ]*e
            arrayToCRT[i] = 1
            TArray[i] = crt(arrayToCRT,nArray)
        P = PolynomialRing(Zmod(prod(nArray)), names=('x',)); (x,) = P._first_ngens(1)
        gArray = [-_sage_const_1 ]*e
        for i in range(e):
            gArray[i] = TArray[i]*(pow(aArray[i]*x + bArray[i],e) - cArray[i])
        g = sum(gArray)
        g = g.monic()
        # Use Sage's inbuilt coppersmith method
        roots = g.small_roots(epsilon=eps)
        if(len(roots)== _sage_const_0 ):
            print("No Solutions found")
            return -_sage_const_1
        return roots[_sage_const_0 ]

    else:
        print("CiphertextArray, ModulusArray, and the linear padding arrays need to be of the same length," +
         "and the same size as the public exponent")

def testLinearPadding():
    from Crypto.PublicKey import RSA
    import random
    import binascii
    flag = b"flag{Th15_1337_Msg_is_a_secret}"
    flag = int(binascii.hexlify(flag),_sage_const_16 )
    e = _sage_const_3
    nArr = [-_sage_const_1 ]*e
    cArr = [-_sage_const_1 ]*e
    aArr = [-_sage_const_1 ]*e
    bArr = [-_sage_const_1 ]*e
    randUpperBound = pow(_sage_const_2 ,_sage_const_500 )
    for i in range(e):
        key = RSA.generate(_sage_const_2048 )
        nArr[i] = key.n
        aArr[i] = random.randint(_sage_const_1 ,randUpperBound)
        bArr[i] = random.randint(_sage_const_1 ,randUpperBound)
        cArr[i] = pow(flag*aArr[i]+bArr[i],e,key.n)
    msg = linearPaddingHastads(cArr,nArr,aArr,bArr,e=e,eps=_sage_const_1 /_sage_const_8 )
    if(msg==flag):
        print("Hastad's solver with linear padding is working! We got message: ")
    msg = hex(int(msg))[_sage_const_2 :]
    if(msg[-_sage_const_1 ]=='L'):
        msg = msg[:-_sage_const_1 ]
    if(len(msg)%_sage_const_2  == _sage_const_1 ):
        msg = '0' + msg
    print(msg)
    print(binascii.unhexlify(msg))
    if(binascii.unhexlify(msg)==flag):
        return True


c1 = 45714565771547930229226359824324184612765804704488147361405122171431410830457625531894507696079301820876695796609440647494597444433096375990065249515774077523541239928616914554861842429334485025363517166565849602924745902936379628721161367954518076487229592008473203339185677650566708246361459229275716576568
c2 = 2938205115049708668056485138176403871361086853648934101627506232566239668541574581519458081557120773367632388591435452676969637296270182244964860487777690358171660162952614090569560548502878423451486434716376263912348986733178496729565668523867452903707337375044080831942666690338685816022188990893636320298
c3 = 34981007099734837238533299758138649644651788051104771864691106724937500933145648874428721015045379341994110064523365875150245487954955323710192812559532234986873511482994229494347841043885794519388227924113364604772627940274894512640323396807771050836451224652645782605991571363112070128949113272566961274576
N = 58875529304338905505953736667221291201023306734480969247806744848754691476474059614663016432386992446676367074190570583945448346734199513681690392081616727023248926447123883344310985916849639888321099825559426707949564522612871413289064362345332045923908212157578793253630638285901734823301475623394385357159

cArray = [c1, c2, c3]
nArray = [N, N, N]

aArray = [7181440813425333706869174610678052506, 71055505674727459802208513173474964857, 111820717202976493862690612149607975104]
bArray = [165133443861765297927799892635709230456, 72432382236220395199525441338281930328, 57478891897114368065422549586619540493]

linearPaddingHastads(cArray,nArray,aArray,bArray,e=3)
